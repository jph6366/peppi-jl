<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Peppi"><title>peppi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="peppi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../peppi/index.html">peppi</a><span class="version">2.1.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#peppi" title="Peppi">Peppi</a><ul><li><a href="#installation" title="Installation">Installation</a></li><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#development" title="Development">Development</a></li><li><a href="#goals" title="Goals">Goals</a></li><li><a href="#peppi-format" title="Peppi Format">Peppi Format</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>peppi</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/peppi/lib.rs.html#1-5">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="peppi"><a class="doc-anchor" href="#peppi">§</a>Peppi</h2>
<p><a href="https://github.com/hohav/peppi/actions/workflows/Build.yml"><img src="https://github.com/hohav/peppi/actions/workflows/test.yml/badge.svg" alt="test" /></a>
<a href="https://crates.io/crates/peppi"><img src="https://img.shields.io/crates/v/peppi.svg" alt="" /></a>
<a href="https://docs.rs/peppi/"><img src="https://docs.rs/peppi/badge.svg" alt="" /></a></p>
<p>Peppi is a Rust parser for <a href="https://github.com/project-slippi/slippi-wiki/blob/master/SPEC.md">.slp</a> game replay files for <a href="https://en.wikipedia.org/wiki/Super_Smash_Bros._Melee">Super Smash Brothers Melee</a> for the Nintendo GameCube. These replays are generated by Jas Laferriere’s <a href="https://github.com/JLaferri/project-slippi">Slippi</a> recording code, which runs on a Wii or the <a href="https://dolphin-emu.org/">Dolphin</a> emulator.</p>
<p>⚠️ The <code>slp</code> tool has moved to the <a href="https://github.com/hohav/peppi-slp">peppi-slp</a> crate.</p>
<h3 id="installation"><a class="doc-anchor" href="#installation">§</a>Installation</h3>
<p>In your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
peppi = &quot;2.0&quot;</code></pre></div><h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<p>One-shot <code>.slp</code> parsing with <a href="https://docs.rs/peppi/latest/peppi/io/slippi/de/fn.read.html">slippi::read</a> (use <a href="https://docs.rs/peppi/latest/peppi/io/peppi/de/fn.read.html">peppi::read</a> instead for <code>.slpp</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{fs, io};
<span class="kw">use </span>peppi::io::slippi::read;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>r = io::BufReader::new(fs::File::open(<span class="string">"tests/data/game.slp"</span>).unwrap());
    <span class="kw">let </span>game = read(<span class="kw-2">&amp;mut </span>r, <span class="prelude-val">None</span>).unwrap();
    <span class="macro">println!</span>(<span class="string">"{:#?}"</span>, game);
}</code></pre></div>
<details>
<summary>A more involved example</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{fs, io};
<span class="kw">use </span>peppi::io::slippi::read;
<span class="kw">use </span>peppi::frame::Rollbacks;

<span class="comment">// `ssbm-data` provides enums for characters, stages, action states, etc.
// You can just hard-code constants instead, if you prefer.
</span><span class="kw">use </span>ssbm_data::action_state::Common::{<span class="self">self</span>, <span class="kw-2">*</span>};

<span class="doccomment">/// Print the frames on which each player died.
</span><span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>r = io::BufReader::new(fs::File::open(<span class="string">"tests/data/game.slp"</span>).unwrap());
    <span class="kw">let </span>game = read(<span class="kw-2">&amp;mut </span>r, <span class="prelude-val">None</span>).unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>is_dead = <span class="macro">vec!</span>[<span class="bool-val">false</span>; game.frames.ports.len()];
    <span class="kw">let </span>rollbacks = game.frames.rollbacks(Rollbacks::ExceptLast);
    <span class="kw">for </span>frame_idx <span class="kw">in </span><span class="number">0</span>..game.frames.len() {
        <span class="kw">if </span>rollbacks[frame_idx] {
            <span class="kw">continue</span>;
        }
        <span class="kw">for </span>(port_idx, port_data) <span class="kw">in </span>game.frames.ports.iter().enumerate() {
            <span class="kw">match </span>port_data
                .leader
                .post
                .state
                .get(frame_idx)
                .and_then(|s| Common::try_from(s).ok())
            {
                <span class="prelude-val">Some</span>(DeadDown)
                | <span class="prelude-val">Some</span>(DeadLeft)
                | <span class="prelude-val">Some</span>(DeadRight)
                | <span class="prelude-val">Some</span>(DeadUp)
                | <span class="prelude-val">Some</span>(DeadUpStar)
                | <span class="prelude-val">Some</span>(DeadUpStarIce)
                | <span class="prelude-val">Some</span>(DeadUpFall)
                | <span class="prelude-val">Some</span>(DeadUpFallHitCamera)
                | <span class="prelude-val">Some</span>(DeadUpFallHitCameraFlat)
                | <span class="prelude-val">Some</span>(DeadUpFallIce)
                | <span class="prelude-val">Some</span>(DeadUpFallHitCameraIce) =&gt; {
                    <span class="kw">if </span>!is_dead[port_idx] {
                        is_dead[port_idx] = <span class="bool-val">true</span>;
                        <span class="macro">println!</span>(
                            <span class="string">"{} died on frame {}"</span>,
                            game.start.players[port_idx].port,
                            game.frames.id.get(frame_idx).unwrap(),
                        )
                    }
                }
                <span class="kw">_ </span>=&gt; is_dead[port_idx] = <span class="bool-val">false</span>,
            }
        }
    }
}</code></pre></div>
</details>
<details>
<summary>Live parsing</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs;
<span class="kw">use </span>std::io::BufReader;
<span class="kw">use </span>byteorder::ReadBytesExt;
<span class="kw">use </span>peppi::io::slippi::de;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>r = BufReader::new(fs::File::open(<span class="string">"tests/data/game.slp"</span>).unwrap());

    <span class="comment">// UBJSON wrapper (skip if using spectator protocol)
    </span><span class="kw">let </span>size = de::parse_header(<span class="kw-2">&amp;mut </span>r, <span class="prelude-val">None</span>).unwrap() <span class="kw">as </span>usize;

    <span class="comment">// payload sizes &amp; game start
    </span><span class="kw">let </span><span class="kw-2">mut </span>state = de::parse_start(<span class="kw-2">&amp;mut </span>r, <span class="prelude-val">None</span>).unwrap();

    <span class="comment">// loop until we hit GameEnd or run out of bytes
    </span><span class="kw">while </span>de::parse_event(<span class="kw-2">&amp;mut </span>r, <span class="kw-2">&amp;mut </span>state, <span class="prelude-val">None</span>).unwrap() != de::Event::GameEnd <span class="kw">as </span>u8
        &amp;&amp; state.bytes_read() &lt; size
    {
        <span class="macro">println!</span>(
            <span class="string">"current frame number: {:?}"</span>,
            state.frames().id.iter().last()
        );
    }

    <span class="comment">// `U` (0x55) means metadata next (skip if using spectator protocol)
    </span><span class="kw">if </span>r.read_u8().unwrap() == <span class="number">0x55 </span>{
        de::parse_metadata(<span class="kw-2">&amp;mut </span>r, <span class="kw-2">&amp;mut </span>state, <span class="prelude-val">None</span>).unwrap();
    }
}</code></pre></div>
</details>
<h3 id="development"><a class="doc-anchor" href="#development">§</a>Development</h3>
<p>The Rust source files in <a href="src/frame"><code>src/frame</code></a> are generated using Clojure from <a href="gen/resources/frames.json"><code>frames.json</code></a>, which describes all the per-frame fields present in each version of the <a href="https://github.com/project-slippi/slippi-wiki/blob/master/SPEC.md">spec</a>. If you modify <code>frames.json</code> or the generator code in <code>gen/src</code>, run <code>gen/scripts/frames</code> to regenerate those Rust files.</p>
<p>If you’re adding support for a new version of the spec, you’ll also need to bump <code>peppi::io::slippi::MAX_SUPPORTED_VERSION</code>.</p>
<h3 id="goals"><a class="doc-anchor" href="#goals">§</a>Goals</h3>
<ul>
<li>Performance: Peppi aims to be the fastest parser for <code>.slp</code> files.</li>
<li>Ergonomics: It should be easy and natural to work with parsed data.</li>
<li>Lenience: accept-and-warn on malformed data, when feasible.</li>
<li>Cross-language support: other languages should be able to interact with Peppi easily and efficiently.</li>
<li>Round-tripping: Peppi can parse a replay and then write it back, bit-for-bit identically.</li>
<li>Alternative format: Peppi provides an <a href="#peppi-format">alternative format</a> that is more compressible and easier to work with than <code>.slp</code>.</li>
</ul>
<h3 id="peppi-format"><a class="doc-anchor" href="#peppi-format">§</a>Peppi Format</h3>
<p>The Peppi format (<code>.slpp</code>) is a <a href="https://en.wikipedia.org/wiki/Tar_(computing)">GNU tar</a> archive containing the following files, in order:</p>
<ul>
<li><code>peppi.json</code>: Peppi-specific info.</li>
<li><code>metadata.json</code>: Slippi’s <a href="https://github.com/project-slippi/slippi-wiki/blob/master/SPEC.md#the-metadata-element">metadata block</a>.</li>
<li><code>start.json</code>: JSON representation of the <a href="https://github.com/project-slippi/slippi-wiki/blob/master/SPEC.md#game-start">Game Start</a> event.</li>
<li><code>start.raw</code>: Raw binary Game Start event.</li>
<li><code>end.json</code>: JSON representation of the <a href="https://github.com/project-slippi/slippi-wiki/blob/master/SPEC.md#game-end">Game End</a> event.</li>
<li><code>end.raw</code>: Raw binary Game End event.</li>
<li><code>frames.arrow</code>: Frame data in Arrow format (see below).</li>
</ul>
<p>The bulk of this data is in <code>frames.arrow</code>, an <a href="https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format">Arrow IPC</a> file containing all of the game’s frame data. This is a columnar format, which makes <code>.slpp</code> about twice as compressible as <code>.slp</code>.</p>
<p>To convert between formats, use the <a href="https://github.com/hohav/peppi-slp"><code>slp</code></a> CLI tool.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="frame/index.html" title="mod peppi::frame">frame</a></div><div class="desc docblock-short">Frame data representation.</div></li><li><div class="item-name"><a class="mod" href="game/index.html" title="mod peppi::game">game</a></div><div class="desc docblock-short">A single game of Super Smash Brothers Melee.</div></li><li><div class="item-name"><a class="mod" href="io/index.html" title="mod peppi::io">io</a></div><div class="desc docblock-short">Serialization and deserialization of replays.</div></li></ul></section></div></main></body></html>